// Generated by CoffeeScript 2.1.0
(function() {
  /*
    2_core_contracts.coffee
    Created by Zefram Lou (Zebang Liu) as part of the WikiGit project.

    This file defines the deployment process of the core contracts of
    the DASP. In addition, it initializes the DASP's Git repo,
    publishes it onto the IPFS network, and saves its hash in the
    GitHandler module.
  */
  var config, dao, fs, git, ipfs, ipfsAPI, main, member_handler, repo_handler, tasks_handler, token, vault;

  //Initialize contract abstractions
  main = artifacts.require('Main');

  dao = artifacts.require('Dao');

  member_handler = artifacts.require('MemberHandler');

  vault = artifacts.require('Vault');

  tasks_handler = artifacts.require('TasksHandler');

  repo_handler = artifacts.require('RepoHandler');

  token = artifacts.require('Token');

  //Import node modules
  ipfsAPI = require('ipfs-api');

  ipfs = ipfsAPI('ipfs.infura.io', '5001', {
    protocol: 'https'
  });

  git = require('gift');

  fs = require('fs');

  //Import config
  config = require('./config.json');

  module.exports = function(deployer) {
    var abiPath;
    abiPath = './build/contracts/';
    return ipfs.util.addFromFs(abiPath, {
      recursive: true
    }, function(error, abiFiles) {
      var getABIHash, mainHash;
      if (error !== null) {
        throw error;
      }
      getABIHash = function(modName) {
        var f, i, len;
        for (i = 0, len = abiFiles.length; i < len; i++) {
          f = abiFiles[i];
          if (f.path === `contracts/${modName}.json`) {
            return f.hash;
          }
        }
      };
      mainHash = getABIHash('Main');
      //Deploy main contract
      return deployer.deploy(main, config.main_metadata, mainHash).then(function() {
        var newHash, repoPath;
        repoPath = './tmp/repo.git';
        if (!fs.existsSync(repoPath)) {
          if (!fs.existsSync('./tmp')) {
            fs.mkdirSync('./tmp');
          }
          fs.mkdirSync(repoPath);
        }
        newHash = '';
        //Initialize Git repo
        return git.init(repoPath, true, function(error, _repo) {
          if (error !== null) {
            throw error;
          }
          //Add repo to the IPFS network
          return ipfs.util.addFromFs(repoPath, {
            recursive: true
          }, function(error, result) {
            if (error !== null) {
              throw error;
            }
            //Get repo's IPFS multihash
            newHash = result[result.length - 1].hash;
            //Deploy core modules
            return deployer.deploy([[dao, main.address], [member_handler, config.member_init_username, main.address], [vault, main.address], [tasks_handler, main.address], [repo_handler, main.address], [token, main.address]]).then(function() {
              //Add core module addresses to main contract
              return main.deployed().then(function(instance) {
                return instance.initializeModuleAddresses([dao.address, member_handler.address, vault.address, tasks_handler.address, repo_handler.address, token.address]);
              });
            }).then(function() {
              var modAbsNames;
              //Initialize the ABI hashes
              modAbsNames = ['Dao', 'MemberHandler', 'Vault', 'TasksHandler', 'RepoHandler', 'Token'];
              return main.deployed().then(function(instance) {
                var initABIHashForMod, modId;
                initABIHashForMod = function(modId) {
                  return instance.initializeABIHashForMod(modId, getABIHash(modAbsNames[modId]));
                };
                return Promise.all((function() {
                  var i, results;
                  results = [];
                  for (modId = i = 0; i <= 5; modId = ++i) {
                    results.push(initABIHashForMod(modId));
                  }
                  return results;
                })());
              });
            });
          });
        });
      });
    });
  };

}).call(this);

//# sourceMappingURL=2_core_contracts.js.map
