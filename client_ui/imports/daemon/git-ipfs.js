// Generated by CoffeeScript 2.0.1
/*
  git-ipfs.coffee
  Created by Zefram Lou (Zebang Liu) as part of the WikiGit project.

  This file implements a daemon that listens for the TaskSolutionAccepted() event
  from the GitHandler module. Upon such an event, the daemon would clone the
  DASP's Git repo, pull from the updated repo where the task has been completed
  to merge the solution into the DASP's repo, publish the resulting repo onto IPFS,
  and send its IPFS multihash back to GitHandler as the current location of the DASP's repo.
*/
var Web3, fs, git, hexToStr, ipfs, ipfsAPI, keccak256, web3;

import {
  dasp
} from '../ui/dasp_dashboard.js';

//Import web3
Web3 = require('web3');

web3 = window.web3;

if (typeof web3 !== void 0) {
  web3 = new Web3(web3.currentProvider);
} else {
  web3 = new Web3(new Web3.providers.HttpProvider("http://localhost:8545"));
}

web3.eth.getAccounts().then(function(accounts) {
  return web3.eth.defaultAccount = accounts[0];
});

//Import node modules
ipfsAPI = require('ipfs-api');

ipfs = ipfsAPI('ipfs.infura.io', '5001', {
  protocol: 'https'
});

git = require('gift');

fs = require('fs');

keccak256 = require('js-sha3').keccak256;

//Helper functions
hexToStr = function(hex) {
  var i, j, ref, str;
  hex = hex.substr(2);
  str = '';
  for (i = j = 0, ref = hex.length - 1; j <= ref; i = j += 2) {
    str += String.fromCharCode(parseInt(hex.substr(i, 2), 16));
  }
  return str;
};

export var StartDaemon = function() {
  var gitHandlerContract, solutionAcceptedEvent, tasksHandlerContract;
  //Fetch contract abstractions
  tasksHandlerContract = dasp.contracts.tasks;
  gitHandlerContract = dasp.contracts.git;
  solutionAcceptedEvent = tasksHandlerContract.events.TaskSolutionAccepted();
  solutionAcceptedEvent.on('data', function(event) {
    var patchIPFSHash;
    patchIPFSHash = hexToStr(event.returnValues.patchIPFSHash);
    return gitHandlerContract.methods.getCurrentIPFSHash().call().then(function(result) {
      var masterIPFSHash, masterPath;
      masterIPFSHash = hexToStr(result);
      masterPath = `./tmp/${masterIPFSHash}/`;
      if (!fs.existsSync(masterPath)) {
        if (!fs.existsSync('./tmp')) {
          fs.mkdirSync('./tmp');
        }
        fs.mkdirSync(masterPath);
      }
      //Clone the master
      return git.clone("git@gateway.ipfs.io/ipfs/" + masterIPFSHash.toString(), masterPath, Number.POSITIVE_INFINITY, "master", function(error, _repo) {
        var repo;
        if (error !== null) {
          throw error;
        }
        repo = _repo;
        //Add patched repo as remote
        return repo.remote_add("solution", `gateway.ipfs.io/ipfs/${patchIPFSHash}`, function(error) {
          if (error !== null) {
            throw error;
          }
          //Pull the patched repo and merge with the master
          return repo.pull("solution", "master", function(error) {
            if (error !== null) {
              throw error;
            }
            //Add new repo to the IPFS network
            return ipfs.util.addFromFs(masterPath, {
              recursive: true
            }, function(error, result) {
              var entry, j, len, results;
              if (error !== null) {
                throw error;
              }
              results = [];
              for (j = 0, len = result.length; j < len; j++) {
                entry = result[j];
                if (entry.path === masterIPFSHash) {
                  gitHandlerContract.methods.commitTaskSolutionToRepo(event.returnValues.taskId, event.returnValues.solId, entry.hash).send();
                  break;
                } else {
                  results.push(void 0);
                }
              }
              return results;
            });
          });
        });
      });
    });
  });
};

//# sourceMappingURL=git-ipfs.js.map
