// Generated by CoffeeScript 2.0.1
/*
  git-ipfs.coffee
  Created by Zefram Lou (Zebang Liu) as part of the WikiGit project.

  This file implements a daemon that listens for the TaskSolutionAccepted() event
  from the GitHandler module. Upon such an event, the daemon would clone the
  DASP's Git repo, pull from the updated repo where the task has been completed
  to merge the solution into the DASP's repo, publish the resulting repo onto IPFS,
  and send its IPFS multihash back to GitHandler as the current location of the DASP's repo.
*/
var Web3, fs, git, gitHandlerAddr, gitHandlerContract, hexToStr, ipfs, ipfsAPI, keccak256, mainAbi, mainAddr, mainContract, tasksHandlerAddr, tasksHandlerContract, web3;

import {
  DASP_Address
} from '../ui/dasp_dashboard.js';

//Import web3
Web3 = require('web3');

web3 = new Web3();

if (web3.currentProvider === null) {
  web3.setProvider(new Web3.providers.HttpProvider("http://localhost:8545"));
}

//Import node modules
ipfsAPI = require('ipfs-api');

ipfs = ipfsAPI('ipfs.infura.io', '5001', {
  protocol: 'https'
});

git = require('gift');

fs = require('fs');

keccak256 = require('js-sha3').keccak256;

//Helper functions
hexToStr = function(hex) {
  var i, j, ref, str;
  hex = hex.substr(2);
  str = '';
  for (i = j = 0, ref = hex.length - 1; j <= ref; i = j += 2) {
    str += String.fromCharCode(parseInt(hex.substr(i, 2), 16));
  }
  return str;
};

//Initialize main contract
mainAddr = DASP_Address.get();

mainAbi = require('../abi/mainABI.json');

mainContract = new web3.eth.Contract(mainAbi, mainAddr);

tasksHandlerAddr = tasksHandlerContract = null;

gitHandlerAddr = gitHandlerContract = null;

//Get TasksHandler address
mainContract.methods.moduleAddresses('0x' + keccak256('TASKS')).call().then(function(result) {
  //Initialize TaskHandler module
  tasksHandlerAddr = result;
  return main.methods.getABIHashForMod('0x' + keccak256('TASKS')).call().then(function(abiHash) {
    return new Promise(function(fullfill, reject) {
      return ipfs.files.cat(hexToStr(abiHash), function(error, stream) {
        if (error !== null) {
          reject(error);
        }
        stream.pipe(bl(function(error, data) {
          var abi;
          if (error !== null) {
            reject(error);
          }
          abi = JSON.parse(data.toString()).abi;
          tasksHandlerContract = new web3.eth.Contract(abi, tasksHandlerAddr);
          fullfill();
        }));
      });
    });
  });
}).then(function() {
  //Get GitHandler address
  return mainContract.methods.moduleAddresses('0x' + keccak256('GIT')).call().then(function(result) {
    //Initialize GitHandler module
    gitHandlerAddr = result;
    return main.methods.getABIHashForMod('0x' + keccak256('GIT')).call().then(function(abiHash) {
      return new Promise(function(fullfill, reject) {
        return ipfs.files.cat(hexToStr(abiHash), function(error, stream) {
          if (error !== null) {
            reject(error);
          }
          stream.pipe(bl(function(error, data) {
            var abi;
            if (error !== null) {
              reject(error);
            }
            abi = JSON.parse(data.toString()).abi;
            gitHandlerContract = new web3.eth.Contract(abi, gitHandlerAddr);
            fullfill();
          }));
        });
      });
    });
  });
}).then(function() {
  var solutionAcceptedEvent;
  //Listen for solution accepted event
  solutionAcceptedEvent = tasksHandlerContract.events.TaskSolutionAccepted();
  return solutionAcceptedEvent.on('data', function(event) {
    var patchIPFSHash;
    patchIPFSHash = hexToStr(event.returnValues.patchIPFSHash);
    return gitHandlerContract.methods.getCurrentIPFSHash().call().then(function(result) {
      var masterIPFSHash, masterPath;
      masterIPFSHash = hexToStr(result);
      masterPath = `./tmp/${masterIPFSHash}/`;
      if (!fs.existsSync(masterPath)) {
        if (!fs.existsSync('./tmp')) {
          fs.mkdirSync('./tmp');
        }
        fs.mkdirSync(masterPath);
      }
      //Clone the master
      return git.clone("git@gateway.ipfs.io/ipfs/" + masterIPFSHash.toString(), masterPath, Number.POSITIVE_INFINITY, "master", function(error, _repo) {
        var repo;
        if (error !== null) {
          throw error;
        }
        repo = _repo;
        //Add patched repo as remote
        return repo.remote_add("solution", `gateway.ipfs.io/ipfs/${patchIPFSHash}`, function(error) {
          if (error !== null) {
            throw error;
          }
          //Pull the patched repo and merge with the master
          return repo.pull("solution", "master", function(error) {
            if (error !== null) {
              throw error;
            }
            //Add new repo to the IPFS network
            return ipfs.util.addFromFs(masterPath, {
              recursive: true
            }, function(error, result) {
              var entry, j, len, results;
              if (error !== null) {
                throw error;
              }
              results = [];
              for (j = 0, len = result.length; j < len; j++) {
                entry = result[j];
                if (entry.path === masterIPFSHash) {
                  gitHandlerContract.methods.commitTaskSolutionToRepo(event.returnValues.taskId, event.returnValues.solId, entry.hash).send();
                  break;
                } else {
                  results.push(void 0);
                }
              }
              return results;
            });
          });
        });
      });
    });
  });
});

//# sourceMappingURL=git-ipfs.js.map
